.pl72
.po10
.HE
.op
.mb 3


*****************************************************************
*                                                               *
*              ****        *       *           ****             *
*             *    *        *     *           *    *            *
*             *              *   *            *                 *
*              ****           * *              ****             *
*                  *           *                   *            *
*             *    *           *              *    *            *
*              ****            *               ****             *
*                                                               *
*****************************************************************





  
=================================================================
=                                                               =
=    Programmsystem zur Entwicklung von Anwenderprogrammen      =
=              Autor H. Blume Karl-Marx-Stadt                   =
=                   Copyright (C) 1986                          =
=                 Ingenieurbuero Bauwesen                       =
=                                                               =
=================================================================




.pa
0.  Inhaltsverzeichnis:
=======================
                                                         Seite
1.   Einleitung                                              1
     1.1.      Dateien                                       1.1
     1.2.      Dateibezeichnung                              1.2
     1.2.1.    Geraetezuweisung                              1.2
     1.2.2.    Dateiname                                     1.2
     1.2.3.    Namenserweiterung                             1.2
     1.3.      Ein- und Ausgaben                             1.3
     1.4.      Systemkomponenten                             1.3

2.   Editor                                                  2
     2.1.      Aufruf des Editors                            2.1
     2.2.      Bedienung des Editors                         2.1
     2.3.      Edit-Kommandos                                2.2
     2.4.      Fehler                                        2.5

3.   Assembler Z80/U880                                      3
     3.1.      Einleitung                                    3.1
     3.2.      Aufruf des Assemblers                         3.1
     3.3.      Optionen                                      3.2
     3.4.      Assemblersprache                              3.2
     3.4.1.    Zeichenvorrat                                 3.2
     3.4.2.    Format des Quellcodes                         3.3
     3.4.3.    Symbole und Marken                            3.4
     3.4.4.    Numerische Konstante                          3.4
     3.4.5.    Ketten und Kettenkonstante                    3.4
     3.4.6.    Befehlszaehler                                3.5
     3.4.7.    Kommentar                                     3.5
     3.4.8.    Sofortbefehle                                 3.5
     3.5.      Ausdruecke                                    3.6
     3.5.1.    Register                                      3.6
     3.5.2.    Variable                                      3.6
     3.5.3.    Operatiosnzeichen                             3.6
     3.5.4.    Bildung eines Ausdruckes                      3.7
     3.5.5.    Typ eines Ausdruckes                          3.7
     3.5.6.    Externe Symbole                               3.7
     3.6.      Pseudooperationen                             3.7
     3.7.      Fehlermitteilungen                            3.11
     3.8.      Protokoll des Assemblers                      3.11
     3.9.      Objektcode                                    3.12
     3.10.     Symboltabelle                                 3.12
     3.11.     Symboldatei                                   3.12

4.   Z8000 Cross Assembler                                   4
     4.1.      Aufruf des Assemblers                         4.1
     4.2.      Sprachelemente                                4.2
     4.3.      Pseudooperationen                             4.3
     4.4.      Operandenstrukturen                           4.6
     4.5.      Arithmetik                                    4.6
     4.5.1.    Zahlen                                        4.6
     4.5.2.    Symbolische Konstante                         4.6
     4.5.3.    Zeichenketten                                 4.6
     4.6.      Ausdruecke                                    4.7
     4.7.      Adressierungsformen                           4.7
     4.7.1.    Segmentierung                                 4.7
     4.7.2.    Adressierungsformen                           4.8
     4.7.3.    -IM- Daten Adressierung                       4.8
     4.7.4.    -R-  Register Adressierung                    4.8
     4.7.5.    -IR- Indirekte Register Adressierung          4.9
     4.7.6.    -DA- direkte Adresse                          4.9
     4.7.7.    -X-                                           4.10
     4.7.8.    -RA-                                          4.10
     4.7.9.    -BA-                                          4.11
     4.7.10.   -BX-                                          4.11
     4.8.      Reservierter Wortschatz                       4.12
     4.9.      Fehlercodes                                   4.12
     4.10      Ausgaben                                      4.13
     4.10.1    Listing                                       4.13
     4.10.2.   Objektcode                                    4.14
     4.10.3.   Symboltabelle                                 4.14

5.   Crossassembler Z8                                       5
     5.1.      Einleitung                                    5.1
     5.2.      Aufruf des Assemblers                         5.1
     5.3.      Optionen                                      5.1
     5.4.      Assemblersprache                              5.2
     5.4.1.    Zeichenvorrat                                 5.2
     5.4.2.    Format des Quellcodes                         5.3
     5.4.3.    Symbole und Marken                            5.3
     5.4.4.    Numerische Konstante                          5.4
     5.4.5.    Ketten und Kettenkonstante                    5.4
     5.4.6.    Befehlszaehler                                5.4
     5.4.7.    Kommentar                                     5.5
     5.4.8.    Sofortbefehle                                 5.5
     5.5       Ausdruecke                                    5.5
     5.5.1.    Register                                      5.5
     5.5.2     Variable                                      5.6
     5.5.3.    Operationszeichen                             5.6
     5.5.4.    Bildung eines Ausdruckes                      5.7
     5.5.5.    Typ eines Ausdruckes                          5.7
     5.5.6.    Externe Symbole                               5.7
     5.6.      Pseudooperationen                             5.7
     5.7       Fehlermitteilungen                            5.9
     5.8       Protokoll des Assemblers                      5.10
     5.9.      Objektcodes                                   5.10
     5.10      Symboltabelle                                 5.11

6.   Crossassembler 8086                                     6
     6.1.      Einleitung
****fehlt noch ***

7.   Macros                                                  7
     7.1.      Definitionen                                  7.1
     7.1.1.    Macrokopf                                     7.1
     7.1.2.    Macrokoerper                                  7.2
     7.2       Ende des Macrokoerpers                        7.2
     7.3       Aufruf des Macros                             7.3
     7.4       Verschachtelung von Macros                    7.3
     
8.   Linker                                                  8
     8.1.      Wirkungsweise                                 8.1
     8.2.      Aufruf des Linkers                            8.1
     8.3.      Kommandofile                                  8.1
     8.4.      Programmanordnung                             8.1
     8.5.      Dateiangeben                                  8.2
     8.6.      Programmangaben                               8.2
     8.7.      Kommentare                                    8.3
     8.8       Listing                                       8.3
     8.9.      Fehler                                        8.3

9.   Verschiebelader                                         9
     9.1.      Wirkungsweise                                 9.1
     9.2.      Aufruf des Verschiebeladers                   9.1
     9.3.      Optionen                                      9.1
     9.4.      Fehler                                        9.2

10.  Turbo-Pascal Parser                                     10



               A N H A N G
               ===========
 

A.   Mnemonik Z80                                            A

B.   Mnemonik Z8000                                          B
     1.        Notation                                      B.1
     1.1.      Adressierungsarten                            B.1
     1.2.      Steuerregister (CTRL)                         B.1
     1.3.      Die Statusflags                               B.2
     1.4.      Interruptsteuerflags                          B.2
     1.5.      Register                                      B.2
     1.6.      Bedingungscodes                               B.2
     1.7.      Abkuerzungen in der Befehlsbeschreibung       B.3
     2.        Mnemonics                                     B.4
     2.1.      Lade- und Austauschbefehle                    B.4
     2.2.      Arithmetische Operationen                     B.5
     2.3.      Logische Operationen                          B.7
     2.4.      Programmsteuerung                             B.7
     2.5.      Bitmanipulation                               B.8
     2.6.      Verschiebebefehle                             B.9
     2.7.      Blocktransporte, Kettenmanipulationen         B.11
     2.8.      Ein- und Ausgabe                              B.15
     2.9.      Steueranweisungen                             B.18

C    Z8 Mnemonik                                             C

D    8086 Mnemonik                                           D


.fi sys1.doc
.fi sys2.doc
.fi sys3.doc
.fi sys4.doc 
.fi sys5.doc
.fi sys6.doc
.fi sys7.doc
.fi sys8.doc
.fi sys9.doc
.fi sys10.doc
.fi c:sysa.doc
.fi c:sysb.doc
.fi c:sysc.doc
.fi c:sysd.doc
 .pl72
.po10
.HECP/B                       Seite 1.   #                     S Y S
.fo                             Gesamtsystem
1.  Einleitung
==============

Das Programmsystem SYS beinhaltet eine Reihe von Programmen,  die 
eine schnelle Herstellung von Anwenderprogrammen fuer Rechner mit 
folgenden CPU:

     U880 (Z80)
     U8000 (Z8001, Z8002)
     U881..883 (Z8)
     8086, iAPX286

mit allen CP/M kompatiblen Betriebssystemen gestatten. Die Bedie-
nung  erfolgt  von einem Minimalmonitor aus  durch  entsprechende 
Aufrufe.  Fuer alle Programmteile ist eine einheitliche Bedienung 
moeglich.



1.1. Dateien
------------

Fuer  die  Arbeit  des gesamten Systems ist die  Dateiarbeit  wie 
folgt  organisiert:  Der  Editor  erzeugt  eine  Quelldatei,  die 
maximal  m-12 K Byte lang sein kann.  m ist  der  zur  Verfuegung 
stehende  RAM-Bereich,  der  z.B.  bei 64k CP/B   52 K  betraegt. 
Diese  Quelle  befindet sich staendig im Speicher  und  wird  vom 
Assembler ohne Datentransporte uebernommen.
Ist eine Quelle laenger als 30k bei CP/B,  so kann mit der Option 
"L" jede beliebige Quelle assembliert werden.
Der  Assembler erzeugt aus dieser Quelle  eine  Objektdatei,  die 
recordweise ausgegeben wird.
Der  Linker  bzw.  Lader  erzeugt dann  eine  abarbeitungsfaehige 
Objektdatei im Intel-Hex-Code bzw. eine COM-Datei.



Die Definitionen der verschiedenen Dateien ist:

Objektdatei    beinhaltet ein ausfuehrbares, absolut adressiertes
               Maschinenprogramm  im  Intel-Hex-Code.  Der  erste 
               Befehl  einer  Objektdatei  ist  ein  Sprung   zum 
               Programmbeginn oder der Programmbeginn selbst.

Quelldatei     beinhaltet  eine  beliebige Darstellung im  ASCII-
               Code.  Die  Quelldatei ist zeilenweise  orientiert 
               und enthaelt keine Zeilennummern.  Eine Zeile wird 
               mit CR (RETURN,  ET1) beendet. Eine Quelldatei ist 
               stets mit 1AH abgeschlossen.

Link-Datei     hat  einen  speziellen Aufbau in  ASCII-Code.  Sie 
               enthaelt  bei  externen  Marken  deren  Namen  und 
               ermoeglicht   damit  dem  Linker   die   Adressen-
               zuweisung.

Listdatei      enthaelt  alle  notwendigen ASCII-Zeichen fuer die
               Ausgabe  eines  Protokolls  einschl.  Seitennumme-
               rierung und Blattwechsel.

Markendatei    enthaelt  alle  Marken eines absoluten  Programmes 
               zur spaeteren Verwendung im symbolischen Debugger.

1.2. Dateibezeichnung
---------------------

Jede Datei hat einen Namen,  der durch das Betriebssystem bedingt 
folgende Konstruktion hat:

     dev:name.ext

Hierin bedeuten

     dev:      Geraetezuweisung
     name      Dateiname
     ext       Namenserweiterung




1.2.1. Geraetezuweisung
-----------------------

Fuer die Auswahl eines Diskettenlaufwerkes,  auf dem eine bestim-
mte Datei existieren soll,  ist eine zusaetzliche Angabe moeglich 
durch dev:  vor dem Dateinamen. dev: kann mit A: fuer Laufwerk 1, 
B: fuer Laufwerk 2 usw. angegeben werden. Ist dev: nicht gegeben, 
wird das aktuelle Laufwerk benutzt.

Die  Zuweisung  eines logischen Geraetes erfolgt ueber die Angabe

     CON: Console
     LST: Drucker
     AUX: Auxilary-Ein-Ausgabe

Der Doppelpunkt ist unbedingt anzugeben, er dient dem Rechner zur 
Kennzeichnung des Laufwerkes bzw. logischen Geraetes.




1.2.2. Dateiname
----------------

Der  Dateiname kann aus einem bis 8 Zeichen bestehen,  wobei  das 
erste  Zeichen ein Buchstabe sein muss.  Ausser  Alfazeichen  ist 
noch  das  Zeichen "$" (24 Hex)  zulaessig.  Zwischen  Gross- und 
Kleinschreibung wird nicht unterschieden.
Ein Dateiname kann beliebig gewaehlt werden.




1.2.3. Namenserweiterung
------------------------

Die   Namenserweiterung  dient  der  Unterscheidung  von  Dateien 
gleichen  Namens und ist vom Namen durch einen Punkt zu  trennen. 
Sie darf aus 3 Zeichen bestehen,  weitere Zeichen sind ungueltig. 
Fehlt diese Angabe (einschliesslich dem Punkt!), setzt das System 
einen Standard:

   Quelldateien          .ASM
   Linkdateien           .HXL
   Objektdateien         .HEX
   Rueckkehrdateien      .BAK
   Listing Assembler     .PRN
   Listing Linker        .PRL
   Hilfsdateien          .$$$
   Markendateien         .SYS



  
1.3. Ein- und Ausgaben
----------------------

Bei der Definition eines Dateinamens bzw. eines logischen  Gerae-
tes wird der Ein- oder Ausgabekanal festgelegt.
Eingaben erfolgen Zeichen fuer Zeichen, bei Disketten ueber einen 
128  Byte langen Puffer.  Die Zeichen werden bei ASCII-Code  ohne 
Paritaetsbitpruefung  jedoch mit 8 Bits gelesen.  Die Zeichen 0aH 
und 7FH werden ueberlesen,  ein Zeichen ^Z (1AH) dient als  Ende-
kennzeichen einer Datei.

Ausgaben werden ebenso behandelt,  jedoch wird nach jedem  RETURN 
(0DH)  ein  Line Feet (0AH) hinzugefuegt.  Das Zeichen 1AH  dient 
wieder als Endekennzeichen der Datei.

Wird  bei  der Ausgabe ein Fehler festgestellt  oder  steigt  das 
gewaehlte  Geraet aus oder ist nicht vorhanden,  wird nach  einer 
Fehlerausschrift:

     Write Error, Abort (Y/N):

der  Fehler  mit  der Eingabe von N uebergangen und  die  Ausgabe 
erfolgt auf dem Bildschirm. Bei der Eingabe von Y wird das momen-
tan laufende Programm abgebrochen und der Monitor eingeschaltet.

Alle Dateien ausser .COM Dateien sind in ASCII-Code dargestellt.




1.4. Systemkomponenten
----------------------

Der Minimalmonitor verwaltet die einzelnen Systembestandteile

     Editor
     Assembler fuer verschiedene Prozessoren
     Linker fuer Z80 und Z8 -Programme
     Verschiebelader fuer U880-Rechner
     Parser fuer Turbopascal

Diese   Systemkomponenten   koennen   mit   folgenden   Kommandos 
aufgerufen werden, nach dem auf dem Display das Menue zur Auswahl 
erscheint.  Eine  falsche Angabe wird ignoriert,  bei der Auswahl 
eines  Assemblers ist darauf zu achten,  dass die Angabe ohne Typ 
auf den U880 schaltet.

     Edit                Auswahl Editor
     Assembler           Auswahl Z80-  Assembler
     Assembler z8        Auswahl Z8-   Assembler
     Assembler z80       Auswahl Z80-  Assembler
     Assembler z86       Auswahl 8086- Assembler
     Assembler z8000     Auswahl Z8000-Assembler
     Assembler 86        Auswahl 8086- Assembler
     Linker              Auswahl Linker fuer Z80 und Z8
     Shiftloader         Auswahl Verschiebelader fuer Z80
     Parser              Auswahl TurboPascal Parser

Der  erste Buchstabe des Aufrufes ist  signifikant.  Alle  andern 
Buchstaben  duerfen entfallen.  Ausser bei Z80-Assembler sind die 
Ziffern vollstaendig einzugeben.
Fehler bei der Eingabe werden angezeigt, fehlende Ueberlagerungs-
programme  fuehren ebenfalls zu Fehleranzeigen.  Die Eingabe kann 
dann richtig wiederholt werden.

Soll  das  Programmsystem verlassen werden,  ist im  Monitor  nur 
RETURN  statt eines Kommandos zu geben.  Das Betriebssystem  wird 
dann ueber einen Warmstart aktiv.


.PL72
.po10
.HECP/B                       Seite 2.   #                     S Y S
.fo                            E D I T O R

2.   EDITOR
===========

2.1. Aufruf
-----------

Vom Monitor oder von jedem Assembler aus kann der Editor mit  dem 
Kommando 
     Edit
aufgerufen werden. Der erste Buchstabe ist signifikant.   
Der  Editor  meldet sich und durchsucht zuerst den Speicher  nach 
einem Quellfile. Ist ein solches vorhanden, wird gefragt:
     dateiname found in Buffer, accept? (Y/N):

dateiname ist der Name der gefundenen Quelldatei.
Bei der Antwort mit Y wird dieses File fuer gueltig erklaert, bei 
N als Eingabe wird dieses File im Speicher geloescht und nach dem 
Namen des Quellfiles gefragt:

     Filename:
Hier ist ein Filename der Form

     dev:name.erw
einzugeben.  Die  Angabe von CON:  gestattet die direkte  Eingabe 
einer Quelle von der Tastatur aus. Sonst wird auf dem angegebenen 
Laufwerk  nach  diesem Namen gesucht und eine Quelldatei  in  den 
Arbeitsspeicher geladen.  Existiert eine solche Datei nicht, wird 
der  Inputmodus eingestellt und eine neue Quelldatei unter diesem 
Namen  kann  eingegeben  werden.
Ist eine einzugebende Quelldatei groesser,  als der Speicherplatz 
dies zulaesst, wird die Fehlermitteilung

     *** MAX ***
ausgegeben  und die Eingabe abgebrochen.  Die Datei kann trotzdem 
in gekuerzter Form bearbeitet werden.  Quellen sollen nie so lang 
werden, denn die Bearbeitungszeit steigt dann wesentlich an.


2.2. Bedienung des Editors
--------------------------

Der Editor meldet sich mit seinem Systemzeichen

          >

Danach  befindet er sich im Kommandoeingabe-Modus.  Ein  Kommando 
kann  eingegeben und durch Parameter naeher spezifiziert  werden. 
Fehlen  Parameter,  wird  fuer die Anzahl 1 und fuer  Ketten  die 
Nullkette gesetzt.  Ist der letzte Parameter ein Dezimalwert,  so 
bezieht er sich auf die Anzahl,  die Nummer der Zeile  o.ae.  Bei 
Angabe  eines * (Sternchen) ist fuer diesen der Dezimalwert 65535 
gesetzt.  Fehlt ein Kommando vollstaendig (nur ET1 druecken),  so 
wird  das  letzte  Kommando  vollstaendig  mit  allen  Parametern 
wiederholt. Dies gilt nicht fuer Macro-Kommandos.
Alle  Antworten  auf  eine  Kommandoeingabe  erfolgen  ueber  den 
Bildschirm.  Die  Ausgabe  einer  Quellzeile  erfolgt  mit  einer 
vorangestellten 5 stelligen Zeilennummer, die dynamisch verwaltet 
wird.


2.3. EDIT-Kommandos
-------------------

Ein  Kommando ist durch seinen ersten Buchstaben  gekennzeichnet. 
Weitere Buchstaben sind unwirksam.  Das erste Leerzeichen,  Stern 
oder  die  erste Ziffer oder ein Escape zeigen den  Beginn  eines 
Parameters  an.  In der folgenden Beschreibung ist das Escape aus 
drucktechnischen Gruenden durch ^[ dargestellt,  n ist eine Dezi-
malzahl.


A n                                                     ASSEMBLER
Der Editor wird verlassen und der Assembler aufgerufen.  n ist in 
diesem  Fall die genauere Auswahl des Assemblers.  Fehlt n,  wird 
der Z80-Assembler aufgerufen.  Die Quelldatei bleibt im  Speicher 
erhalten.

     n = 8          Z8-   Assembler
     n = 80         Z80-  Assembler
     n = 8000       Z8000-Assembler
     n = 86         8086- Assembler



B                                                          BOTTOM
Der Zeilenzeiger wird auf die letzte Zeile der Quelldatei gesetzt 
und diese Zeile auf der Konsole ausgegeben.


C^[kette1^[kette2^[n                                       CHANGE
Ab  der aktuellen Zeile wird auf n Zeilen,  die die Kette  kette1 
enthalten, diese durch die Kette kette2 ersetzt. Entfaellt n, ist 
das  Kommando  nur fuer die erste Zeile wirksam,  die  die  Kette 
kette1  enthaelt.  Fehlt kette2,  so wird kette1  geloescht.  Ist 
kette1  in  einer Zeile nicht enthalten,  wird diese Zeile  nicht 
veraendert. Steht * fuer n, wird das Auswechseln fuer die gesamte 
restliche Datei vorgenommen.



Dn                                                         DELETE
D^[kette
Ab  der  aktuellen Zeile werden n Zeilen geloescht  bzw.  ab  der 
Zeile bis zu der Zeile,  die die angegebene Kette kette enthaelt, 
werden  alle  Zeilen geloescht.  Diese letzte Zeile mit  der  ge-
suchten Kette wird nicht geloescht.
Wird  dieses Kommando vor der ersten Zeile (vor dem  Dateianfang) 
gegeben, ist es wirkungslos.



E dev:name.erw                                               EXIT
Die  generierte  Quelldatei wird unter dem angegebenen Namen  auf 
das   angegebene  Laufwerk  ausgegeben.   Fehlt  .erw,   ist  die 
Erweiterung  standardmaessig .ASM.  Eine evtl.  vorhandene  Datei 
dev:name.$$$ wird vorher geloescht,  falls dies gewuenscht  wird. 
Die  neue  Quelldatei wird mit der Erweiterung .$$$  erzeugt.  Es 
folgt  eine  Kontrolle  auf richtige Uebertragung  und  dann  die 
Umbenennung  von  .ASM in .BAK fuer die alte Quelldatei  und  von 
.$$$ in .ASM fuer die neue Quelldatei.
Wird kein Dateiname angegeben, so ist der beim Aufruf des Editors 
angegebene Name gueltig. 
Nach  diesem  Kommando wird der Editor verlassen und der  Monitor 
aktiv. 



F^[kette                                                     FIND
In der Datei wird ab der naechsten Zeile nach der aktuellen Zeile 
nach  einer Zeile gesucht,  die die angegebene Kette enthaelt und 
diese  Zeile angezeigt.  Die Datei wird bis zum Ende  durchsucht, 
falls die Kette nicht gefunden wird.



Gn                                                             GO
G^[kette
Es wird der Zeilenzeiger auf die n.  Zeile bzw. auf die Zeile mit 
der  angegebenen  Kette gesetzt und diese  Zeile  angezeigt.  Die 
Suche erfolgt vom Dateianfang an.



I                                                           INPUT
Input-Modus.  Hier  kann eine Datei aufgebaut  werden.  Nach  der 
Ausgabe  der  aktuellen Zeilennummer kann eine satzweise  Eingabe 
von   Quellzeilen   erfolgen.   Es  werden   alle   ASCII-Zeichen 
akzeptiert.  Zweimalige  Eingabe  von ET1  (RETURN)  beendet  den 
Inputmodus.  Alle  eingegebenen Zeichen werden nach der aktuellen 
Zeile  eingefuegt,  die gerade einzugebende Zeile wird  dann  die 
aktuelle Zeile. Zeilen nach dieser Einfuegung bleiben erhalten.



I kette                                                    INSERT
Der Abschluss des I-Kommandos mit einem Leerschritt gestattet die 
Einfuegung  einer  Zeile nach der aktuellen Zeile.  Alle  Zeichen 
nach  diesem 1.  Leerschritt werden bis zum  abschliessenden  ET1 
eingefuegt.



K                                                          KURSOR
Die  aktuelle Zeile wird angezeigt und der Kursor auf  das  erste 
Zeichen dieser Zeile gesetzt. Nun kann mit den Kursorsteuertasten 
der  Kursor beliebig bewegt werden.  An beliebiger Stelle koennen 
dann  Zeichen  eingefuegt  (einfach  eintippen)  oder   geloescht 
werden.  Mit  der Angabe von ^D wird das Zeichen,  unter dem  der 
Kursor steht, geloescht.



^Q beendet dieses Kommando, ohne die angezeigte Zeile im Speicher 
zu veraendern.
Ein  RETURN  speichert die veraenderte Zeile.  Ebenso wirken  die 
Kursortasten -Kursor hoch, -Kursor runter.
Ein TAB in der Zeile wird als Leerzeichen dargestellt.



Ln                                                           LADE
Ab  der aktuellen Zeile werden aus einer externen Datei n  Zeilen 
in die Quelldatei eingefuegt. Alle L-Kommandos laden stets ab der 
ersten  Zeile  der  externen  Datei.  Nach  dem  Dateinamen  wird 
gefragt.  Er  muss eingegeben werden.  Die Namenserweiterung  ist 
standardmaessig .$$$.  Alle logische Eingabegeraete sind als dev: 
zulaessig.



M&kom1&kom2&...&komi                                        MACRO
Die  Kommandos kom1 bis komi werden gekettet und spaeter mit  dem 
Kommando Xecute nacheinander ausgefuehrt.  Es sind alle Kommandos 
ausser dem MACRO-Kommando selbst zulaessig.



N^[kette                                                     NEXT
Nn
Der  Zeilenzeiger  wird um n Zeilen weiter in Richtung  Dateiende 
bzw. bis zur Kette verschoben und diese Zeile angezeigt.



O^[kette                                                   OUTPUT
On
Ausgabe  von n Zeilen bzw.  bis zu der Zeile mit der  angegebenen 
Kette  ab  der aktuellen Zeile auf eine externe Datei.  Nach  dem 
Namen  dieser  Datei  wird  gefragt.  Die  Namenserweiterung  ist 
standardmaessig .$$$.  Es ist jedes logische Geraet angebbar.
L- und O-Kommandos dienen der kurzfristigen Auslagerung einzelner 
Quellzeilen. Sie eroeffnen eine Zwischendatei und nach dem Daten-
transport wird diese Datei wieder geschlossen.  Bei Anwendung des 
O-Kommandos wird eine Datei unter diesem Namen vorher geloescht.



Pn                                                          PRINT
P^[kette
Ab  der aktuellen Zeile werden n Zeilen auf der Konsole  ausgege-
ben.  Bei  der  Angabe einer Kette sind alle Zeilen  bis  zu  der 
Zeile,  die diese Kette enthaelt,  auf der Konsole sichtbar.  Das 
Bild wird zeilenweise gerollt.  Unterbrechungen der Ausgabe koen-
nen  durch  Druecken von ^S unterbrochen werden (Halt)  und  nach 
erneutem Betaetigen von ^S weiter ausgegeben werden.  Ein ^C nach 
einem Halt bricht das gesamte Programm SYS ab, das Betriebssystem 
ist aktiv!



Q                                                            QUIT
Die  Datei im Speicher wird nicht mehr veraendert und auch  keine 
Datei  ausgegeben.  Das  Editieren  ist beendet und  der  Monitor 
wieder  aktiv.  Fuer eine Speicheruebersicht wird die Anzahl  der 
editierten Bytes angegeben.



R kette                                                   REPLACE
Die  aktuelle Zeile wird durch die angegebene Kette ersetzt.  Die 
Kette  muss  vom Kommando durch genau  ein  Leerzeichen  getrennt 
sein. Alle ASCII-Zeichen wie bei Input sind bis zum abschliessen-
den RETURN gueltig.


T                                                             TOP
Der Zeilenzeiger wird vor den Dateianfang gesetzt



Un                                                             UP
Der  Zeilenzeiger wird um n Zeilen nach oben in Richtung Dateian-
fang verschoben und diese Zeile angezeigt.



X                                                          XECUTE
Ausfuehrung der mit dem MACRO-Kommando eingegebenen Kommandos  in 
der Reihenfolge, wie dort angegeben.



2.4. Fehler
-----------

Alle Fehler,  die waehrend der Editierung auftreten, sind auf der 
Konsole im Klartext dargestellt. Dabei bedeuten:

     *** ???***
     es wurde ein falsches  Kommando oder eine falscher Parameter 
     gegeben
     
     ***MAX***
     Das   Speicherende  ist  erreicht,   weitere  Eingaben  sind 
     fehlerhaft.

.PL72
.po10
.HECP/B                       Seite 3.   #                     S Y S
.fo                            ASSEMBLER Z80

3.   ASSEMBLER Z80
==================

3.1. Einleitung
---------------

Der Assembler gestattet es, die Mnemoniks von robotron oder ZILOG 
zu verwenden. Bei genuegend kleinen Quellen bleibt die Quelldatei 
im  Speicher  und  es  sind  sehr  kurze  Bearbeitungszeiten  zur 
Fehlerkorrektur moeglich.
Zum vollstaendigen Ablauf der Assemblierung gehoeren 2 Laeufe. Im 
ersten  Pass  wird  ein Adressbuch angelegt und im  2.  Pass  der 
Objektcode   erzeugt,   ein   Listing  ausgegeben   und   weitere 
Informationen mitgeteilt. Die Beendigung des 1. Passes wird durch 
eine Ausschrift mitgeteilt.  Die Uebersetzung wird bei  Auftreten 
von  Fehlern nicht abgebrochen,  sondern weiter versucht und alle 
Fehler werden auf der Konsole angezeigt.


3.2. Aufruf des Assemblers
--------------------------

Der Assembler wird vom Monitor oder vom Editor mit dem Kommando
     Assembler z80
aufgerufen.  Der erste Buchstabe ist fuer den Aufruf signifikant, 
weitere Angaben brauchen nicht gemacht werden.
Der Assembler meldet sich und erwartet die Eingabe von Optionen.

Ist  im  Speicher  bereits eine Quelldatei  vorhanden,  wird  sie 
verwendet. Andernfalls wird nach dem Namen der Quelldatei gefragt 
und diese geladen, wenn nicht die Option L verwendet wird.


3.3. Optionen
-------------

Optionen  sind  durch  Kommata  getrennte  Angaben  zur  naeheren 
Bestimmung  des Uebersetzungslaufes.  Abschluss der Kommandozeile 
ist ET1.   Die Uebersetzung wird nach ET1 sofort  begonnen.  Wird 
kein Kommando eingegeben, setzt das System einen Standard:
     -absolut assemblieren
     -keine Objekt-, Link- oder MAP-Datei erzeugen
     -keine Listdatei erzeugen
     -Fehler ueber Konsole ausgeben
     -Die Quelle hat im Speicher vollstaendig Platz
Nach einem Uebersetzungslauf erscheint ebenfalls die Aufforderung 
nach der Eingabe von Optionen und es koennen neue Optionen einge-
geben werden. Bei einer Wiederholung des Uebersetzungslaufes wird 
der  erste  Pass  nicht nochmal abgearbeitet.  Dadurch  kann  ein 
Wechsel  von  relativer zu absoluter Uebersetzung  und  umgekehrt 
nicht erfolgen.
Die Optionen koennen sein:

     E    Editor. Der Editor wird geladen. Falls die Quelle im
          Speicher steht, wird sie beibehalten.

     H    Header,  es  wird  die  Kopfzeile  mit  dieser  Angabe 
          ergaenzt.  Maximal  68 Zeichen moeglich.  Diese  Angabe 
          wird  jedoch  durch die  Assembleranweisungen  *H  oder 
          TITLE ueberschrieben.

     L    Long, die Quelldatei wird von Diskette gelesen und darf
          deshalb beliebig lang sein. Eine Quelldatei im Speicher
          muss  vorher gerettet  werden, deshalb  wird der Editor
          nachgeladen  und die Ausgabe vor der Assemblierung ver-
          langt.

     M    Macros  sind  erlaubt.  Je Angabe von M (auch  mehrfach 
          moeglich) werden im  RAM 400H Bytes (1k Byte) fuer  die 
          Macros   reserviert.   Macros  sollten  ohne  Kommentar 
          geschrieben  werden,  da dieser  ebenfalls  gespeichert 
          wird.

     O    Ausgabe  des Objektcodes.  Spaeter wird nach dem  File-
          namen fuer den Objektcode gefragt.

     P    Ausgabe des Listings

     Q    Rueckkehr in den Monitor

     R    relative Uebersetzung

     S    Ausgabe der Symboltabelle

     Y    Ausgabe der Markendatei. 

Die Uebersetzung erfolgt absolut,  falls nicht die Option R gege-
ben wurde.
Die Option Y muss nach!  einem vorherigen 1. Pass gegeben werden, 
sonst  ist  sie wirkungslos.  

Bei  den  Optionen  O,  S,  P und Y wird  nach  einem  Dateinamen 
gefragt,  ebenso,  wenn die Quelle noch nicht im Speicher  steht. 
Die Fragen sind mit der Namensangabe

     dev:name.erw

zu beantworten. Siehe auch Angaben im Kapitel 1.

Bei  den Optionen S und Y wird nach der Abarbeitung des Passes  2 
der  Pass  2  nicht  nochmals  wiederholt,   sondern  sofort  die 
gewuenschte Liste erzeugt.


3.4. Assemblersprache
---------------------

Die  vom Assembler akzeptierten Mnemoniks sind im Anhang  angege-
ben. Die Uebersetzung erfolgt fuer beide Sprachen.

3.4.1. Zeichenvorrat
--------------------

Buchstaben sind die Zeichen des Alphabets:
     A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, 
     U, V, W, X, Y, Z,
     a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t,
     u, v, w, x, y, z
     Ausser  in  Zeichenketten  wird  nicht  zwischen  Gross- und 
     Kleinschreibung unterschieden.
     Die Ausgabe des Listings erfolgt ausser in Zeichenketten nur in 
     Grossbuchstaben. 


Ziffern sind die Dezimalziffern:
     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
     und bei hexadezimaler Schreibweise  die Buchstaben A,  B, C, 
     D, E und F.

Trennzeichen  dienen der Trennung von Bezeichnungen und Ausdruek-
ken und bestehen aus den Zeichen

     SP   Space, Leerschritt
     HT   Horizontaltabulator
sie koennen in beliebiger Menge stehen.

Endezeichen  dienen der Beendigung des signifikanten Teils  einer 
Quellzeile:

     ;    Semikolon, es kann ein Kommentar folgen
     CR   ET1, RETURN, Ende einer Zeile

Sonderzeichen werden in Ausdruecken verwendet:
     &    logisches Und
     (    Klammer auf
     )    Klammer zu, paarweise verwenden!
     *    Multiplikationszeichen
     /    Divisionszeichen
     #    Doppelkreuz und
     $    Dollar fuer den aktuellen Befehlszaehlerstand
     .    Punkt zur Kennzeichnung logischer Operationen
     +    Pluszeichen
     -    Minuszeichen
     ,    Komma,  Trennzeichen zwischen Registern,  Listentrenn-
          zeichen
     :    Doppelpunkt, wahlweiser Markenbegrenzer

Begrenzer, werden je nach Notwendigkeit benutzt:

     : , . ) SP HT ;

Alle  anderen druckbaren Zeichen aus dem ASCII-Vorrat koennen  in 
Zeichenketten Verwendung finden.  VT (Vertikaltabulation) und  FF 
(Blattwechsel) sind verboten.


3.4.2. Format des Quellcodes
----------------------------

Jede  Anweisung wird auf einer Zeile geschrieben.  Ist das  erste 
Zeichen  einer  Zeile  ein Endezeichen,  wird diese  Zeile  nicht 
assembliert.   Ist   das  erste  Zeichen  ein  *,   so  ist   ein 
Sofortkommando  auszufuehren.  Alle anderen Anweisungen  erfolgen 
nach dem Schema:

     MARKE[:]  OPCODE    AUSDRUCK

Wird keine Marke angegeben,  muss die Zeile mit mindestens  einem 
Trennzeichen beginnen.
Zwischen   MARKE   und  OPCODE  muss  entweder   mindestens   ein 
Trennzeichen oder der Doppelpunkt stehen,  falls kein Endezeichen 
die  Zeile  abschliesst.  Eine  Marke muss nicht  ab  der  ersten 
Position beginnen,  wenn sie mit einem  Doppelpunkt abgeschlossen 
wird. 


3.4.3. Symbole und Marken
-------------------------

Eine Marke dient der Markierung einzelner Anweisungen,  wobei ihr 
Wert  der Befehlszaehlerstand des ersten Bytes  dieser  Anweisung 
ist. Marken koennen maximal aus 6 Alfazeichen bestehen, das erste 
Zeichen  muss ein Buchstabe sein.  Innerhalb einer Marke  duerfen 
einige Sonderzeichen stehen:

     $  ?  =  _ (Unterstreichung)

Die  Marke wird durch ein Trennzeichen oder den Doppelpunkt  oder 
ein   Endezeichen  abgeschlossen.   Mehr  als  6  Zeichen  werden 
ueberlesen.
Ein Symbol ist eine Marke, deren aktueller Wert in einem Ausdruck 
verwendet wird. Hier sind die Registernamen nicht gestattet!


3.4.4. Numerische Konstante
---------------------------

Numerische Konstante sind Zahlen,  die in Ausdruecken  Verwendung 
finden. Es gibt verschiedene Darstellungen:

          0101101B
   ---binaere Darstellung
      Verwendung finden die Ziffern 0 und 1.  Die Binaerzahl muss 
      mit dem Buchstaben B abgeschlossen sein.

          7213O     oder      72130Q
   ---oktale Darstellung
      Verwendung  finden die Ziffern 0 bis 7.  Die Oktalzahl muss 
      mit dem Buchstaben O oder Q abgeschlossen sein.

          1250      oder      1250D
   ---dezimale Darstellung
      Verwendung finden die Ziffern 0 bis 9. Die Dezimalzahl kann 
      mit dem Buchstaben D abgeschlossen werden.

          0FF5CH
   ---hexadezimale Darstellung
      Verwendung finden die Ziffern 0 bis 9 und die Buchstaben  A 
      bis  F fuer die Pseudodezimalen 10 - 15.  Eine Hexadezimal-
      zahl  muss mit dem Buchstaben H abgeschlossen sein und  mit 
      einer Ziffer beginnen (Null evtl. voranstellen).

Der Zahlenbereich ist
     vorzeichenloses Byte               0 bis 0FFH
     Byte mit Vorzeichen             -7FH bis +7FH
     Wort                               0 bis 0FFFFH


3.4.5. Ketten und Kettenkonstante
---------------------------------

Ketten  sind eine Folge von beliebigen druckbaren  ASCII-Zeichen. 
Die  Zeichen werden in Hochkomma  eingeschlossen,  das  Hochkomma 
selbst muss doppelt angegeben werden,  um es einmal darzustellen. 
In Ketten sind CR, LF, VT und FF nicht erlaubt. Die Abspeicherung 
erfolgt im Programm von links nach rechts,  jedes Zeichen  belegt 
ein Byte. 
Kettenkonstante  sind Ketten mit einem oder zwei  Zeichen,  deren 
ASCII-Wert  interpretiert  wird und als Zahl  in  einem  Ausdruck 
Verwendung findet.


3.4.6. Befehlszaehler
---------------------

In  einem Ausdruck kann der Befehlszaehlerstand  als ein  16-Bit-
Wert  Verwendung finden.  Zur Kennzeichnung werden die Zeichen  $ 
oder   #  verwendet.   Ein  solches  Zeichen  in  einem  Ausdruck 
repraesentiert  damit  die 16 Bit des Befehlszaehlers  zu  diesem 
Zeitpunkt. Der Typ dieses Wertes ist relativ.


3.4.7. Kommentar
----------------

In  jeder  Zeile  kann ein Kommentar  angegeben  werden.  Er  ist 
gekennzeichnet  durch  ein beginnendes Semikolon  und  endet  mit 
einem ET1. Kommentare sind bei der Uebersetzung wirkungslos.


3.4.8. Sofortbefehle
--------------------

Folgende  Sofortkommandos  sind  implementiert,   die  bei  einem 
Auftreten im Programm sofort ausgefuehrt werden:

*Eject    Blattwechsel im Listing

*Head txt Erzeugen  eines Kopftextes auf Zeile 1 des Listings. Es 
          werden  bis 64 Zeichen akzeptiert.  Ausserdem wird  ein 
          Blattwechsel ausgefuehrt.  

*LISTOFF Die Listing-Ausgabe wird unterdrueckt

*LISTON  Die Listing-Ausgabe wird weitergefuehrt. Beide Kommandos 
         sind auszuschreiben!

*INCLUDE  name   Die  mit name bezeichnete Datei wird  an  dieser 
          Stelle  in den Quellcode zusaetzlich in  voller  Laenge 
          eingefuegt  und mit uebersetzt.  name ist ein nach  den 
          oben  angegebenen Regeln konstruierter  Dateiname  (mit 
          d:name.erw,  wobei die Angabe von name unbedingt erfor-
          derlich ist). 

*PRINTX   text    Der  angegebene Text wird  auf  dem  Bildschirm 
          angezeigt.  Die  Ausgabe  erfolgt sowohl bei Pass1  als 
          auch bei Pass2.

Sofortkommandos  beginnen  mit einem * und sind  mit  dem  ersten 
Buchstaben signifikant ausser LISTON und LISTOFF 




3.5. Ausdruecke
---------------

Ausdruecke  sind  beliebige,  mit arithmetischen  oder  logischen 
Operationen  verknuepfte Konstante,  Symbole oder Variable  sowie 
Registernamen.



3.5.1. Register
---------------

Als Operanden koennen die Register der CPU 880 sowohl als Einzel- 
wie auch als Doppelregister verwendet werden.

Einzelregister sind:
     A, B, C, D, E, H, L, I, R  und die Teile der Indexregister
     LX, LY    fuer den LOW-Teil und
     HX, HY    fuer den HIGH-Teil


Doppelregister sind:
     AF, BC, DE, HL, SP, IX, IY und
     PC (dargestellt durch die Zeichen # oder $)


3.5.2. Variable
---------------

Variable  sind  Werte,  die sich auf RAM-Plaetzen befinden und  8 
oder  16  Bit  lang sein koennen.  Bei 16  Bit  langen  Variablen 
befinden  sich auf dem addressierten Speicherplatz die unteren  8 
Bit  und  auf  dem  folgenden Speicherplatz  die  oberen  8  Bit. 
Variable werden in einem Ausdruck durch ein Symbol beschrieben.


3.5.3. Operationszeichen
------------------------
Folgende Operationszeichen koennen verwendet werden:

Rang Zeichen   Wirkung
 1   .LOW.     nur die niederen 8 Bit eines Wortes
 1   .HGH.     nur  die oberen 8 Bit eines Wortes,  als untere  8 
               Bit interpretiert
 1   .SHL.     Verschiebung  des  links  vom  Operationszeichen 
               stehenden Ausdruckes um soviel Stellen nach links,
               wie der rechts stehende Ausdruck angibt
 1   .SHR.     wie vor, jedoch Verschiebung nach rechts

 2     *       Multiplikation 16 Bit ohne Beruecksichtigung des
               Ueberlaufes
 2     /       Division 16 Bit ganzzahlig ohne Runden
 2   .MOD.     Rest einer ganzzahligen Division

 3     +       Addition 16 Bit ohne Ueberlauf
 3     -       Subtraktion 16 Bit ohne Ueberlauf

 4   .NOT.     Negation 16 Bit des folgenden Ausdruckes
 5   .AND.     logische Konjunktion 16 Bit
 6   .XOR.     logische Inhibition 16 Bit
 7   .OR.      logische Disjunktion 16 Bit

Die Zeichen +, -, .NOT., .LOW. und .HGH. koennen allein vor einem 
Ausdruck stehen,  alle anderen Operationszeichen muessen zwischen 
zwei Operanden stehen.


3.5.4. Bildung eines Ausdruckes
-------------------------------

Ein  Ausdruck wird durch die Verknuepfung von Zahlen,  Variablen, 
numerischen- und Kettenkonstanten  gebildet.   Die   Verknuepfung 
mittels  Operationszeichen wird innerhalb des gleichen Ranges von 
links  nach  rechts ausgefuehrt,  sonst die Operationen  mit  dem 
hoechsten Rang zuerst. Runde Klammern, die stets paarweise stehen 
muessen,   durchbrechen  diese  Reihenfolge.   Ein   geklammerter 
Ausdruck  wird  wie ein Operand verwendet.  Die Klammertiefe  ist 
nicht unbegrenzt, ein entsprechender Fehler wird angezeigt.
Ein  Ausdruck  besitzt nach seiner Bildung einen  16  Bit  langen 
Wert,  die  vorderen Bits evtl.  mit Null  aufgefuellt.  Negative 
Werte werden im Zweierkomplement dargestellt.


3.5.5. Type eines Ausdruckes
----------------------------

Ein  Ausdruck  kann sowohl absolut als auch  relativ  sein.  Dies 
haengt davon ab, ob in ihm programmrelative Werte vorhanden sind. 
Der  Typ des Ausdruckes wird im Listing mit dargestellt durch die 
Zeichen:
     R    relativ
     A    absolut
     E    external

Bei  der  Berechnung  des Ausdruckes  wird  eine  Typueberwachung 
durchgefuehrt und Verknuepfungen zwischen nicht zulaessigen Typen 
verhindert.  Die  Differenz zweier relativer Werte  ergibt  dabei 
einen absoluten Wert!


3.5.6. Externe Symbole
----------------------

Sind  bestimmte Symbole in einem Programm noch nicht bekannt  und 
koennen diese nur von anderen Programmen bestimmt werden, so sind 
diese Symbole mit der Pseudoanweisung EXTERNAL zu deklarieren.



3.6. Pseudooperationen
----------------------

Zur Steuerung des Uebersetzungslaufes werden bestimmte  Operatio-
nen benoetigt,  die nicht zum Befehlssatz der CPU gehoeren. Diese 
Pseudooperationen werden nachfolgend erlaeutert:

DW   ausdruck
DEFW ausdruck
DA   ausdruck

Das  den Wert des Ausdruckes repraesentierende Wort wird  gespei-
chert.

DB   ausdruck,ausdruck,...
DEFB ausdruck,ausdruck,...

Die  Folge von durch Kommata getrennten Ausdruecken wird als Byte 
erwartet  und abgespeichert.  Die Anzahl der Ausdruecke  ist  auf 
Zeilenlaenge beschraenkt (max 64).

DB   'text'
DEFM 'text'

Diese  Anweisung erzeugt beliebigen Text im ASCII-Code.  Der Text 
muss als Zeichenkette angegeben werden,  deren Laenge 64  Zeichen 
nicht uebersteigen darf.

DEFT 'text'

Diese Anweisung wirkt die DEFM, jedoch wird die Laenge des Textes 
als erstes Byte ausgegeben.


BER  Ausdruck
DEFS Ausdruck

Diese  Anweisung  reserviert innerhalb des  Programmes  Speicher-
plaetze,  deren  Anzahl  durch den Wert des  Ausdruckes  bestimmt 
wird.  Dieser  Wert  muss bereits im ersten Pass  vorher  bekannt 
sein. Im Programm haben diese Speicherplaetze einen undefinierten 
Inhalt.  

name      DEF  ausdruck
name      DEFL ausdruck

Der   Wert  des  Ausdruckes  wird  einmalig!   dem  Symbol   name 
zugewiesen.  Fehlt  name,  entsteht ein Fehler wie auch bei einer 
nochmaligen  Verwendung  des  Namen als Marke  an  einer  anderen 
Stelle.

PN   text
NAME text

Es  werden  maximal 6 Zeichen als  Programmname  akzeptiert.


EJEC
EJECT

Innerhalb des Listings wird ein Blattwechsel ausgefuehrt

END  Ausdruck

Mit  dieser Anweisung wird das Programm beendet,  weitere  Zeilen 
werden  nicht  mehr gelesen.  Der Wert des  Ausdruckes  wird  bei 
absoluter  Assemblierung  im  Endeblock des  Intel-Hex-Codes  als 
Einsprungadresse  angegeben.  Der Ausdruck muss deshalb auf  eine 
Marke fuer den Programmstart hinweisen.  Fehlt der Ausdruck,  ist 
dieser Wert Null.
.cp10
IF   Ausdruck
COND Ausdruck

Wenn der Wert des Ausdruckes Null ist, wird die Assemblierung bis 
zum Auftreten der Anweisung ENIF unterbrochen (die entsprechenden 
Zeilen werden ueberlesen).

ENIF
ENDIF
ENDC

Ende  der  bedingten  Assemblierung.   

IF1

Die Bedingung ist wahr, wenn der Pass 1 abgearbeitet wird

IF2

Die Bedingung ist wahr, wenn der Pass 2 abgearbeitet wird

ELSE

Die mit IF, IF1 oder IF2 gestellte Bedingung wird umgekehrt

Alle IF-Anweisungen duerfen bis 16-fach geschachtelt werden.



LISTOFF 

Das Listing wird ab hier unterdrueckt

NLIST   ausdruck

Ist der Wert des Ausdruckes Null oder fehlt er,  wird das Listing 
ab diesem Zeitpunkt unterdrueckt.

LIST    ausdruck
LISTON  ausdruck

Ist  der  Wert des Ausdruckes Null oder fehlt  er,  so  wird  das 
Listing  ab diesem Zeitpunkt nach einem Ausschalten des  Listings 
weitergefuehrt, sonst ist die Anweisung wirkungslos.

PRINTX    text

Der  angegebene  Text  wird auf  dem  Bildschirm  angezeigt.  Zur 
Unterscheidung  zwischen  Pass1 und Pass2 koennen  die  bedingten 
Anweisungen IF1 und IF2 verwendet werden.


ORG  Ausdruck

Dem  Befehlszaehler  wird  der Wert  des  Ausdruckes  zugewiesen. 
Dieser Wert muss bereits im ersten Pass vorher bekannt sein.  Bei 
relativer  Assemblierung  sollte diese Anweisung nicht  verwendet 
werden.



EXTE     Liste
EXTERNAL Liste

Liste ist eine Aufzaehlung von Markennamen, durch Komma getrennt. 
Diese  Marken  werden in die Markenliste aufgenommen und mit  dem 
Wert  Null belegt.  Sie koennen erst beim Linken mit  einem  Wert 
belegt  werden.   Ihr  Typ  ist  E  (External).  Wird  eine Marke 
angegeben,  die  bereits im Programm enthalten ist,  wird  Fehler 
angezeigt und diese Marke nicht nochmals aufgenommen.


GLOB   Liste
GLOBAL Liste

Liste ist eine Aufzaehlung von Markennamen, durch Komma getrennt. 
Diese Anweisung zeigt anderen Programmen die Adressen von Marken, 
die  in diesem Programm definiert sind.  Die Marken werden gesam-
melt  und stehen dann dem Linker zur Verfuegung.  Ist eine  Marke 
angegeben,  die  nicht  im Programm enthalten  ist,  wird  Fehler 
angezeigt.

name      EQU  ausdruck

Der  Wert  des Ausdrucks ausdruck wird der Marke name  zugewiesen 
und bleibt bis zu einer evtl. neuen Wertzuweisung erhalten.

TITL  text
TITLE text

Diese Pseudoanweisung wirkt wie das Sofortkommando *H text (siehe 
dort).

name      MACR      dummylist

Vereinbarung eines Makrokoerpers mit Parametern (dummy) unter dem 
Namen name.  Die Parameter duerfen entfallen,  mehrere  Parameter 
werden durch Komma getrennt.

ENDM

Abschluss einer Makrovereinbarung

Makros siehe Kapitel 7 mit genauer Beschreibung

.pa
3.7. Fehlermitteilungen
-----------------------

Entsteht waehrend der Assemblierung ein Fehler auf einem externen 
Geraet,  wird die Assemblierung abgebrochen oder die Ausgabe  auf 
Display  versucht.  Alle  anderen Fehler werden auf  der  Konsole 
angezeigt  mit  der  Ausgabe  der fehlerhaften  Zeile  und  einem 
vorangestellten Buchsteben, der auf den Fehler hinweist. 


Buchst.        Art des Fehlers

 A        Ueberlauf des Makropuffers  *Abort
 B        Ungueltiger Operator
 C        nicht verschiebbarer Ausdruck
 D        falsches Zeichen in einer Zahl (Digit)
 E        externes Symbol in einem Ausdruck
 F        Symboltabelle voll          *Abort
 G        INCLUDE ist geschachtelt
 H        unzulaessiger Typ des Operanden
 I        Unzulaessiger Operand
 J        Unzulaessiger Begrenzer
 K        Sprungweite zu gross bei relativen Spruengen
 L        Unzulaessige Markenkonstruktion
 M        mehrfach definiertes Symbol
 N        Marke erforderlich bei DEFL, EQU
 O        ungueltiger Operationscode (Mnemonik)
 Q        Hochkommas oder IF-ENDIF nicht geradzahlig
 R        Zahlenbereichsfehler
 S        Syntaxfehler allgemein
 T        Eingabezeile zu lang, abgeschnitten
 U        Undefiniertes Symbol
 V        Ausdruck ausserhalb des darstellbaren Bereiches
 W        MACRO vorhanden und nicht erlaubt   *Abort
 X        Symboltabellen Fehler               *Abort
 Y        Undefinierte Bedingung

Die  mit  *Abort gekennzeichneten Fehler fuehren zum Abbruch  der 
Uebersetzung und zur Rueckkehr in den Monitor.


3.8. Protokoll des Assemblers
-----------------------------

Das  Listing ist ein Protokoll  des  Assemblierungsvorganges.  Es 
wird formatiert ausgegeben in der folgenden Form:

Erste Zeile mit Modulnamen und Anwendertext aus *H oder TITLE
Kopfzeile mit einer Ueberschriftenzeile und in  der 3.  Zeile der 
Dateiname  und  das  Datum,  falls es  vorher  im  Betriebssystem 
vereinbart wurde.
Nach einer Leerzeile beginnt der Assemblertext.  Es wird je Zeile 
der  aktuelle Befehlszaehlerstand und der uebersetzte  Objektcode 
ausgegeben.  Danach  erfolgt die Darstellung des  Quelltextes  in 
Grossbuchstaben.  Zur Darstellung des Types eines Ausdruckes wird 
noch  ein Buchstabe vor dem Opcode ausgegeben.
Fehler  werden  in der ersten Spalte durch  den  Fehlerbuchstaben 
angezeigt.  Je  Seite werden 72  Druckzeilen  ausgegeben,  Blatt-
wechsel erfolgt automatisch einschl. der Seitenzaehlung.


3.9. Objektkode
---------------

Der  Objektkode  wird  im  Intel-Hex-Code  ausgegeben,   der  bei 
relativer Assemblierung noch modifiziert wird. Um Kompatibilitaet 
zu erreichen, werden alle Sonderausgaben mit $ statt : markiert.

Am Anfang wird der Modulname mit KZ 5 ausgegeben.
Danach folgen die globalen Marken mit KZ 2.
Der  folgende  Programmtext  wird  normal  ausgegeben.   Je  nach 
Erfordernis  wird bei relativer Assemblierung noch eine Liste der 
relativen  Adressen und bei Auftreten einer externen Marke  deren 
Name und die Adresse ihres Auftretens mit KZ 4 bzw. 3 ausgegeben.
Der Intel-Endeblock (KZ 1) beschliesst die Ausgabe.
Bei  relativer  und absoluter Assemblierung sind die  Daten  ohne 
weiteres mit DDT oder LOAD lesbar, die Sonderausgaben werden dort 
ueberlesen. Deshalb brauchen absolut assemblierte Programme nicht 
gelinkt  zu werden,  sie koennen sofort mit DDT oder LOAD geladen 
werden.



3.10. Symboltabelle
-------------------

Die  Symboltabelle  wird  auf  dem  mit  LIST  gewaehlten  Geraet 
ausgegeben.  Die  Ausgabe erfolgt 4 spaltig mit Name  der  Marke, 
deren Typ und deren Adresse.


3.11. Symboldatei
-----------------

Fuer die Testung des Programmes mit dem symbolischen Debugger SDT 
kann eine Liste aller Marken mit deren Adresse ausgegeben werden. 
Die Ausgabe erfolgt nach der Abarbeitung des 2.  Passes bei einer 
anschliessenden  Eingabe der Option Y.  Der Dateiname wird  abge-
fragt.  Es  muss fuer SDT der gleiche Name wie das Objektprogramm 
gewaehlt werden.
.PL72
.po10
.HECP/B                       Seite 7.   #                     S Y S
.fo                            M A C R O

7.   Makros
===========

Jeder  Assembler  gestattet  das Arbeiten  mit  Macros,  die  bei 
bestimmten  Programmstrukturen  wesentlich  zur  Verkuerzung  der 
Entwicklungszeit  beitragen koennen.  Hier ist bei den Assemblern 
Z8,  Z80 auch die Moeglichkeit des INCLUDE besonders nutzbar,  um 
ganze Bibliotheken aufzubauen.

Der  Assembler benoetigt drei Bereiche,  um Makros definieren  zu 
koennen.  Diese Bereiche werden wie folgt in den Speicher  einge-
ordnet:

a) Macroquellenpuffer
Dieser Puffer wird durch die Option M reserviert und zwar bei der 
ersten  Angabe von M mit 300H Bytes und bei jeder weiteren Angabe 
von  M  zusaetzlich mit 400H Bytes.  Dieser Platz  geht  von  der 
Markentabelle ab, sodass hier genau ueberlegt werden muss.

b) Parameterpuffer
Dieser  Puffer steht am Ende des Makroquellenpuffers und hat  80H 
Bytes  Laenge.  Dies reicht in jedem Fall zur Unterbringung aller 
Parameter, die auf einer Zeile angegeben werden koennen.

c) Macroverschachtelungsstack
Er  steht  nach dem Parameterpuffer und hat eine Laenge  von  80H 
Bytes.   Da  je  Macro- Verschachtelungstiefe  6  Byte  benoetigt 
werden,  sind 21 Schachteltiefen moeglich. Dies ist in jedem Fall 
ausreichend.


An  den letzten Puffer schliesst sich unmittelbar  das  Betriebs-
system an.  Dies ist normalerweise das BDOS.  sind jedoch mit dem 
OPEN-Kommando   andere  Systemprogramme  in  das   Betriebssystem 
eingefuegt worden, werden diese nicht ueberschrieben.



7.1. Definition
===============

Eine Makrodefinition hat folgende Struktur:
     Makrokopf
     Macrokoerper


7.1.1. Macrokopf
----------------

     MACNAM    MACR      P0,P1,P2,...

Der Kopf der Makrodefinition wird durch das Finden der Pseudoope-
ration  MACR identifiziert.  Der Makrokopf beginnt stets mit  der 
Vorgabe  eines Makronamens,  welche der Syntax einer Marke unter-
liegt.  Ausserdem  enthaelt die Zeile eine allgemeine  Parameter-
liste.  Als  Parameter koennen beliebige Zeichenfolgen  definiert 
werden. Begrenzer trennen die Parameter voneinander.
Parameter koennen jedoch auch entfallen.


7.1.2. Macrokoerper
-------------------

Der Makrokoerper besteht aus einer Summe von Quellzeilen,  die an 
beliebiger Stelle Parameter enthalten koennen. Aufgabe des allge-
meinen  Parameters ist es,  Platz zu halten und an der Stelle  im 
Makrokoerper  die  beim Aufruf  uebergebenen  Werte  einzusetzen. 
Jeder Parameter im Operandenfeld muss von Begrenzern eingeschlos-
sen sein. 

Jede Zeile des Macrokoerpers wird nach dem Auftreten von Bezeich-
nungen durchsucht, die einem Parameter entsprechen und dann durch 
den  Wert  des beim Aufruf des Macors angegebenen Parameters  er-
setzt.

Koennen  Konstruktionen  im Makrokoerper  als  Parameter  erkannt 
werden und sind diese jedoch beim Aufruf nicht angegeben, so wird 
der Wert des Parameters mit Null belegt und eingefuegt.

Innerhalb  des Makrokoerpers sind noch einige Besonderheiten  der 
Befehlsabwicklung eingebaut:

     a)   Kommentare werden mit gespeichert und stehen bei Aufruf 
          des Makros wieder zur Verfuegung.

     b)   Sollen  Kommentare nicht gespeichert werden (spart viel 
          Platz), so ist das eroeffnende Semikolon zweifach anzu-
          geben.  Diese  Kommentare werden dann nicht bei  Aufruf 
          des Makros ausgegeben.

     c)    Fuer  die Assembler Z8 und Z80 gibt es  die  Anweisung 
          REPT.  Alle  Anweisungen  zwischen dem Macroanfang  und 
          dieser  Angabe werden sooft ausgefuehrt,  wie der  Aus-
          druck nach REPT angibt. Beispiel:

     ;Makrokoerper:
     TEST    MACR
             DEFB   0 
             REPT   3;; gilt fuer 3 Wiederholungen
             ENDM

          Bei Aufruf des Makros wird folgender Kode erzeugt:

        TEST
     +  DEFB   0
     +  DEFB   0
     +  DEFB   0

          Der Kommentar wird nicht gespeichert.


7.2. Ende des Macrokoerpers
===========================

Der Macrokoerper muss mit der Pseudoanweisung 

     ENDM

abgeschlossen werden.


7.3. Aufruf des Macros
======================


Die  Ausfuehrung  des  Makros ist dann an  beliebiger  Stelle  im 
Quellprogramm  moeglich.  Wird eine Makrodefinition von NLIST und 
LIST eingeschlossen, bleibt sie bei der Listausgabe verborgen.

o.g. Beispiel kann aufgerufen werden:

     EX        R2,@R15
     MACNAM    #ADDR,LD,R9
     PUSHL     @R15,RR2

Die Einfuegung fuer MACNAM sieht dann so aus:
     LD   R1,#ADDR
     LD   R9,#ADDR+1
     
oder z.B.
     MACNAM    POINT-1,JP,Z

Die Einfuegung sieht hier dann so aus:
     LD   R1,POINT-1
     JP   POINT-1+1
     
Der Aufruf des Makros erfolgt ueber seinen Namen,  der im  Opera-
tionsfeld  anzugeben  ist.  Enthaelt die aktuelle  Parameterliste 
weniger Parameter als in der Vereinbarung,  so werden die fehlen-
den Felder als Null angenommen.


     

7.4. Verschachtelung von Macros
===============================

Makros koennen verschachtelt werden,  auch rekursiv.  Dabei  wird 
eine  interne Steuerung ueber den Namen wirksam,  die die  Rekur-
sionstiefe  bis  21 Ebenen ermoeglicht.  Marken innerhalb  dieser 
Makros muessen dann folgenden Namensaufbau haben:

     LAB$$

Statt  den $$ wird intern eine Zahl gesetzt,  die der  Schachtel-
tiefe entspricht.

Der   Abbruch   der  Verschachtelung   ist   z.B.   ueber   einen 
Aufrufzeahler erreichbar.

     SELF      MCR       ....
          .
          .
     COUNT     DEFL      CONST-1
     CONST     DEFL      COUNT
               IF        COUNT
               ...
               ENDIF
               .
               .
               ENDM

Die zum Abbruch des Selbstaufrufes erforderlichen  Pseudoinstruk-
tionen koennen mit NLIST und LIST unsichtbar gemacht werden.  Ein 
mit der Verschachtelung und dem Mehrfachaufruf von Macros verbun-
denes Problem besteht in der Behandlung von Macrointernen Marken, 
da  diese bei jedem Aufruf nochmals definiert werden und so  eine 
fehlerhafte  Quellzeile erzeugen.  Deshalb wird die  Moeglichkeit 
der  Angabe von 2 "$" Zeichen nacheinander innerhalb des  Marken-
namens  (gesamt jedoch nur 6 Zeichen) gestattet.  Die 2 $-Zeichen 
werden intern mit den Buchstaben A ..  Z belegt und gestatten  so 
eine Unterscheidung der Marken je Schachtelung. 
.PL72
.po10
.HECP/B                       Seite 8.   #                     S Y S
.op

8.   Linker
===========

8.1. Wirkungsweise
------------------

Waehrend  der  Eingabe der Namen der  zu  verbindenden  Programme 
werden   die   dazugehoerigen   MAP-Dateien  gesucht   und   eine 
Markenliste aufgebaut. Damit stehen dem Linker alle Informationen 
zum Verbinden der Programme zur Verfuegung.
Danach  erfolgt  ein  2.   Pass,  in  dem  die  Verbindungen  auf 
Zulaessigkeit  getestet  werden.  Ausserdem  kann hier  auch  die 
Programmausgabe erfolgen.


8.2. Aufruf des Linkers
----------------------

Der Linker wird vom Monitor aus mit dem Kommando

     Link
aufgerufen. Der erste Buchstabe ist signifikant.


8.3. Kommandofile
-----------------

Nach dem Aufruf des Linkers wird nach einem Kommandofile gefragt. 
Dieses  Kommandofile  kann  mit einem beliebigen  Editor  erzeugt 
werden  und  muss  alle Angaben enthalten,  die  sonst  von  Hand 
eingegeben  werden.  Das Kommandofile wird durch ein  nochmaliges 
RETURN am Ende aller Angaben abgeschlossen.
Wird bei der Namensangabe das logische Geraet
     CON:
gewaehlt,  koennen  die  Linkangaben von der Tastatur  eingegeben 
werden. Ein Kommandofile muss die Namenserweiterung .CRL haben.


8.4. Programmanordnung
----------------------

Die Reihenfolge der Eingabe der Dateinamen entscheidet ueber ihre 
Stellung  im  Programm,  wenn  nicht Ladeadressen  etwas  anderes 
befehlen. Diese Ladeadressen koennen fuer jedes Programm vorgege-
ben  werden  und legen den Anfang dieses Programmes  im  Speicher 
relativ zur Ladeadresse des ersten Programmes fest.
Wird  keine  Ladeadresse angegeben,  wird die erste Datei ab  der 
Adresse  0 und alle weiteren Dateien lueckenlos daran  anschlies-
send gelinkt. 
Die  Eingabe der Dateinamen kann durch RETURN abgeschlossen  wer-
den.  Mit diesem Abschluss braucht jedoch der  Verbindungsvorgang 
noch  nicht  abgeschlossen  zu sein.  Es ist  vielmehr  moeglich, 
Programmabschnitte nacheinander zu verbinden und sich die fehlen-
den Marken anzeigen zu lassen.  Bei jedem RETURN wird die Verbin-
dung der bereits angegebenen Dateien versucht.  Dabei werden  um-
fangreiche Fehlerkontrollen durchgefuehrt. Sind alle Verbindungen 
fehlerfrei,  kann  das fertige Programm ausgegeben  werden.  Nach 
jeder  Kommandozeile  ist die Ausgabe der Ladeadresse der  bisher 
verbundenen  Dateien  einschl.  ihrer globalen  Marken  moeglich. 
Weiterhin wird eine grobe Speicherbelegung angezeigt.


8.5. Dateiangaben
-----------------

Die  zu verbindenden Dateien sind mit ihrem Namen anzugeben.  Die 
volle  Namenskonstruktion  wie  im  Kapitel  1  beschrieben   ist 
moeglich. Logische Geraete muessen jedoch vermieden werden:

     dev:name.erw

dev: und/oder .erw koennen entfallen. Fuer dev: wird das aktuelle 
Laufwerk gesetzt und fuer .erw die Namenserweiterung .HXL
Um auch absolute Programme verbinden zu koennen (natuerlich  nur, 
wenn  sie auch auf die gleichen Adressen gelinkt werden,  wie  in 
der jeweiligen ORG-Anweisung angegeben),  kann die Namenserweite-
rung in diesem Fall .HEX sein.

Die  Angabe der Ladeadresse der Datei erfolgt durch die Konstruk-
tion:

     dateiname(adresse)

Die Klammer schliesst die Adresse, die hexadezimal angegeben werden 
muss,  jedoch ohne H!, ein.  Fuehrende Nullen muessen entfallen, es 
sind maximal 4 Hex-Ziffern eingebbar.

Um Systemdateien oder andere Markenlisten mit zu  verbinden,  ist 
die Angabe

     dateiname/(adresse)

moeglich.  Die  Datei  wird nur mit ihren globalen Marken  einge-
fuegt, bei Angabe der Adresse mit entsprechender Verschiebung.

Ist  eine Datei als absolut gekennzeichnet,  muss sie  mit  einer 
Adressenangabe gelinkt werden,  wobei die Adresse der ORG-Adresse 
des Files entsprechen muss.  In diesem Fall ist auch die Dateina-
menserweiterung .HEX
Alle Adressangaben beziehen sich auf den Anfang der ersten Datei. 
Wird z.B. 

     name1,name2(2000)

gegeben,  wird die Datei name1 ab 0 und die Datei name2 ab  2000H 
verbunden.

Alle Dateibezeichnungen sind durch ein Komma voneinander zu tren-
nen. Die Kommandozeile wird durch ein RETURN beendet.


8.6. Programmausgabe
--------------------

Wird  nach  der Angabe aller zu verbindenden Dateien  ein  Gleich-
heitszeichen  eingegeben  (kann auch auf einer der folgenden  Kom-
mandozeilen stehen),  so wird die Eingabe eines Dateinamen  erwar-
tet,  unter dem das fertige Programm ausgegeben werden soll.  Hier 
gilt das gleiche wie oben gesagt.  Die Namenserweiterung ist stan-
dardmaessig  .HEX;  fehlt die Laufwerksangabe,  ist  das  aktuelle 
Laufwerk  gemeint.  Die  Ausgabe ist aber auch auf  einem  anderen 
logischen Geraet moeglich, da ACSII-Code erzeugt wird.
Nach  dem  Dateinamen kann ausserdem noch eine durch eine  Klammer 
eingeschlossene  Adresse angegeben werden.  Diese Adresse ist  die 
Anfangsadresse des erzeugten Programms.  Fehlt diese Angabe,  wird 
die Anfangsadresse auf 100H (TPA) gesetzt:

     =nameo(500)

Die  im  obigen Beispiel gelinkten Dateien werden  verbunden  und 
unter   dem  Namen  nameo  im  Intel-Hex-Code   ausgegeben.   die 
Ladeadressen des o.g. Beispiels sind dann:
     name1     =  500H
     name2     = 2500H


8.7. Kommentare
---------------

Auf jeder Kommandozeile koennen Kommentare nach jedem Namen  einge-
fuegt  werden.  Ein Kommentar beginnt nach dem Zeichen ";" (Semiko-
lon) und endet entweder mit einem Semikolon,  welches wie ein Komma 
zwischen  den Dateinamen wirkt oder mit einem Return als  Abschluss 
der Zeile.  Kommentare sind wirkungslos und werden nur beim Listing 
mit ausgegeben.
Beispiel: 
name1;Datei Nr. 1;name2;Datei Nr. 2;(2000)


8.8. Listing
------------

Wird auf einer neuen Kommandozeile 

     #dev:name.erw

gegeben,  wird  ein  Protokoll  des  bisherigen  Standes  der  zu 
verbindenden  Dateien  mit  ihrer Startadresse und  den  globalen 
Marken ausgegeben.
Die Erweiterung ist standardmaessig .PRL, falls nicht im Kommando 
anders angegeben.  Fuer dev:  gilt das oben gesagte.  Ebenso kann 
ein logisches Geraet, insbesondere CON: angegeben werden.
Das Listing wird mit Blattkopf,  in dem ausser einer Ueberschrift 
noch das Datum (falls generiert) und der Dateiname des  gelinkten 
Programms stehen. Die Seitennummerierung erfolgt automatisch.


8.8. Fehler
-----------

Fehler werden erkannt und auf der Konsole im Klartext ausgegeben. 
Nach  Abschluss jeder Kommandozeile wird die momentane  Speicher-
belegung  angezeigt.  Vor der Angabe einer Ausgabeadresse bezieht 
sich die Speicherbelegung stets auf die Anfangsadresse  0.  Diese 
Belegung  muss  durch die Consoleingabe von Y oder  N  bestaetigt 
werden. Bei N wird die bisherige Belegung geloescht.
Nach  der  Angabe  einer  Ausgabeadresse wird  nun  die  richtige 
Speicherbelegung angezeigt und kann bestaetigt werden.

Hat man einen Fehler gemacht,  kann durch Eingabe eines Fragezei-
chens  als  erstes Zeichen einer Kommandozeile  der  Grundzustand 
hergestellt  werden  und alle Eingaben einschl.  der  Angabe  des 
Kommandofiles koennen von vorn wiederholt werden.

Der  Linker wird durch Eingabe von RETURN als erstes und einziges 
Zeichen einer Kommandozeile verlassen.

Ein Kommandofile kann fuer das obige Beispiel so aussehen:

name1,name2(2000)=nameo
#con:
(RETURN)

Nach  der  Erzeugung des Programmes wird das  Protokoll  auf  dem 
Bildschirm ausgegeben.
.PL72
.po10
.HECP/B                       Seite 9.   #                     S Y S
.fo                            VERSCHIEBELADER

9. Verschiebelader
==================

9.1. Wirkungsweise
------------------

Der  Verschiebelader gestattet das Herstellen von  ablauffaehigen 
Programmen, die mit dem Programm SYS entwickelt wurden. Dazu sind 
mehrere   Moeglichkeiten  installiert,   die  die  Vorzuege   des 
Betriebssystems voll ausnuetzen.

Aus einem Intel-Hex-Code,  der entweder vom Linker oder auch  vom 
Assembler  Z80  oder Z8 kommen kann,  wird das Programm  und  die 
dazugehoerige  Verschiebeinformation gelesen und in eine absolute 
Adressierung umgewandelt.  Die relativen Bytes werden jedoch  ge-
merkt,  um  fuer  relative Programme die Verschiebbarkeit zu  ge-
waehrleisten.

Ein  Laden  in  den  Speicher  erfolgt  nicht,  sondern  nur  die 
Erzeugung eines ladbaren Files.


9.2. Aufruf
-----------

Der Verschiebelader wird vom Monitor aufgerufen mit

     Shiftloader

Der erste Buchstabe ist signifikant.
Die Ueberlagerung wird geladen und meldet sich mit  ihrem  Namen. 
Danach wird nach dem Namen des Objektfiles gefragt. Die Namensan-
gabe ist nach den Ausfuehrungen im Kapitel 1 zu konstruieren,  es 
sind  die  Angabe  eines Laufwerkes und  einer  Namenserweiterung 
moeglich.  Fehlt eine dieser Angaben,  wird als Standard das  ak-
tuelle Laufwerk und fuer die Namenserweiterung
      .HEX
gesetzt.

Auf der gleichen Zeile koenen noch Optionen angegeben werden, die 
vom  Namen  durch einen oder mehrere Leerschritte getrennt  sind. 
Die  Zeile  wird mit RETURN beendet und  der  Umcodierungsvorgang 
beginnt.


9.3. Optionen
-------------

Fuer eine komfortable Verwendung der erzeugten Programme ist  die 
Angabe einer Option erlaubt. Die Option L kann jedoch zusaetzlich 
stets vor Angabe einer anderen Option stehen.

     Lx        Auswahl  des   Laufwerkes,  auf  dem  das  fertige 
               Programm ausgelagert werden soll.
               x ist die Laufwerksangebe (A,...,D).  Der Name des 
               erzeugten  Programmes ist der gleiche wie  der  in 
               der Kommandozeile als Objektfile angegebene.

Wird  ausser L keine weitere Option gegeben,  ist das Programm ab 
100H (TPA) als -.COM File lad- und abarbeitbar.
Nachfolgend  wird  immer das maximal moegliche Kommando  mit  der 
Option angegeben. Die Optionen sind:

     R                        c:test1.hex Lb R
     Es wird ein File erzeugt,  welches mit dem OPEN-Kommando des 
     Betriebssystems geladen und als Bestandteil des Betriebssys-
     tems eingefuegt wird.  Das File enthaelt einen Verschiebela-
     der  auf 100H,  der die Zelle MEMGR (29H) abfragt und  damit 
     den  freien  Speicherplatz unter dem Betriebssystems  ermit-
     telt.  Nach  dem Laden dieses Programmes wird dieses an eine 
     freie Stelle verschoben,  die relativen Verbindungen  aufge-
     loest und das Programm angesprungen.
     Die Namenserweiterung des erzeugten Files ist .REL

     O.erw                    b:test2.hex Lc O.ovr
     Es  wird ein .COM-File erzeugt ab Adresse 100H mit der  Ori-
     ginaladresse aus den Angaben des Linkers bzw. des Assemblers 
     bei  ORG.  Es wird keinerlei Verschiebung vorgenommen,  alle 
     Referenzen beziehen sich auf den Programmanfang. Damit koen-
     nen z.B. Betriebssysteme als File erzeugt werden, die jedoch 
     mit  speziellen Ladeprogrammen dann an die  richtige  Stelle 
     geladen werden muessen.
     Die Erweiterung der Option mit .erw gestattet die  Namenser-
     weiterung des erzeugten Programmes beliebig zu waehlen.  Der 
     Standard  ist .COM,  im obigen Beispiel heisst das File dann 
     TEST2.OVR

     C:adr                    a:test3.hex Lb C:2000
     Wie vor wird ein selbstverschiebliches Programm erzeugt. Die 
     andere Wirkung der Option bezieht sich auf die Ladeadresse.
     Wird  adr nicht angegeben,  so wird der CCP (Command Proces-
     sor)  durch das Programm waehrend des  Ladevorganges  ueber-
     schrieben.
     Die  Angabe der Adresse bewirkt das Laden des Programmes auf 
     die angegebene Adresse.  Dabei wird BDOS ueberwacht und  nur 
     nach Bestaetigung der Frage
          BDOS Overwrite? (Y/N):
     mit Y dies zugelassen. Bei der Antwort N wird die Ladeadres-
     se so berechnet, dass nur der CCP ueberlegert wird.

     H:adr                    d:test4.hex La H:5100
     Fuer spezielle Zwecke ist es moeglich, das geladene Programm 
     auf die angegebene Adresse zu binden und dann  anschliessend 
     als Intel-Hex-File auszugeben.  Wird adr nicht angegeben, so 
     bleibt die Adresse aus dem Linkvorgang erhalten.


9.4. Fehler
-----------

Auftretende  Fehler  werden  im  Klartext  angezeigt.  CRC-Fehler 
werden  nur angezeigt,  der Ladevorgang jedoch nicht abgebrochen. 
Eingabefehler fuehren zum Abbruch des Verschiebeladers.


.PL72
.po10
.HECP/B                       Seite x.   #                     S Y S
.fo                       TURBO PASCAL PARSER

1.   Einleitung
===============

Fuer den Inline-Assembler von Turbo Pascal ist es sehr schwer, die 
erforderlichen Codes zu schreiben.  Lange Quellen in Maschinencode 
sind  fast ueberhaupt nicht zu bearbeiten.  Aus diesem Grund wurde 
der  hier beschriebene Parser geschaffen,  der dem Anwender  diese 
Arbeit abnimmt.
Der  Parser ist Bestandteil des Programmes SYS und durch die  dort 
angewandten Ausgaben fuer alle Assembler anwendbar. Die erfolgrei-
che  Testung  konnte jedoch nur bei  Z80  Prozessoren  vorgenommen 
werde.


2.   Aufruf
===========

Der Parser wird vom Monitor mit dem Kommando

     Parse

aufgerufen.  Der  erste Buchstabe (P) ist signifikant.  Der Parser 
benoetigt einen relative Objektcode,  der mit einem Assembler  des 
Systems erzeugt werden muss.  Die Quelle darf kein 'ORG' enthalten 
und  die  Uebersetzung muss relativ erfolgen.  Gelinkte  Programme 
sind nicht anwendbar.
Nach  dem Laden der Ueberlagerung wird nach dem Namen des  Objekt-
codes gefragt mit

     Input File:

Das Eingabefile hat standardmaessig die Namenserweiterung .HXL

Danach muss der Name des Ausgabefiles eingegeben werden:

     Output File:

Hier ist die Namenserweiterung .PAS Standard, wie von Turbo Pascal 
gefordert.
Die Programmabarbeitung beginnt und nach Ausgabe des  Inline-Codes 
wird der Monitor wieder aktiv.


3.   Aufbau des Quellcodes
==========================


Die  zu  assemblierende Quelle muss den vom  jeweiligen  Assembler 
geforderten  Aufbau haben.  Eine ORG-Anweisung darf nicht oder nur 
mit dem Argument Null vorhanden sein.
Alle  fuer  Turpo Pascal erforderlichen Namen der  Variablen  usw. 
sind am Programmanfang als Extern zu erklaeren.
Die Assemblierung hat relativ zu erfolgen,  wo eine Wahl  hierfuer 
besteht (Z80 und Z8).
Die Anwendung von Macros ist beliebig moeglich.
Die Quelle muss aus einem Stueck bestehen.  Laengere Quellen koen-
nen  mit  mehreren getrennten Uebersetzungen und  dann  getrennten 
Einfuegungen in Turbo Pascal bearbeitet werden.


4.   Ausgabe
============

Die Ausgabe erfolgt in der Form

     INLINE ($opcode/
             $opcode/adresse
             $opcode/external
             ....
             $opcode)

auf  ein  File  mit dem angegebenen Namen.  Dieses File  ist  ohne 
Aenderungen von Turbo Pascal als Include-File verwendbar.



5.   Fehler
===========

Treten waehrend der Bearbeitung Fehler auf,  werden sie im Klatext 
angezeigt. Dies sind i.a. Diskettenfehler oder Speicherfehler.
Intern koennen 4 K fuer externe Symbole (ca.  400 Marken) und  bis 
12 K Programmcode gespeichert werden. Groessere Programme erzeugen 
Speicherfehler.

.PL72
.po10
.HECP/B                       Seite A.   #                     S Y S
.fo                            Z80 MNEMONIK 

Anlage    A
===========    

                    ***  Z80 Mnemonik ***


Verwendete Abkuerzungen:
------------------------

( )  Klammern um einen Ausdruck bedeuten Inhalt des Ausdruckes
(l)  untere 8 Bit
(h)  obere 8 Bit
b    Bit-Position in Register oder Speicherstelle
cc   Flagauswertung:
     NZ   ungleich Null
     Z    gleich Null
     NC   kein Uebertrag
     C    Uebertrag
     PO   Ungerade oder kein Ueberlauf
     PE   Gerade oder Ueberlauf
     P    Positiv
     M    Negativ
CY   Carry-Flag
Z    Zero-Flag
d    Zielregister 8 Bit
dd   Zielregister 16 Bit
aa   Zieladresse im Speicher 16 Bit
e    8 Bit Zweierkomplement der Distanz bei relativen Spruengen
     oder indizierter Adressierung
L    8 spezielle Zieladressen der Seite 0:
     0 entspricht Adresse 00H
     1    "         "     08H
     2    "         "     10H
     3    "         "     18H
     4    "         "     20H
     5    "         "     28H
     6    "         "     30H
     7    "         "     38H
     die Werte sind einander aequivalent
n    8 Bit Binaerzahl
nn   16 Bit Binaerzahl
r    allgemeines 8-Bit-Register:
     A, B, C, D, E, H, L oder M bzw (HL)
ss   16 Bit Senderegister
ss'  16 Bit Hintergrundregisterpaar
dd+  Register wird um 1 erhoeht         dd:=dd+1
dd-  Register wird um 1 vermindert      dd:=dd-1
+-   angebbares  Vorzeichen  +  oder -.  Fehlt es,  muss  auch  e 
     fehlen!
vgl  Vergleich Register A mit einem Wert ohne Veraenderung von A
(C)  Bei  Ein- und  Ausgaben wird die Portadresse im  Register  C 
     angegeben.
.PA
Mnemonik       Operation           Bemerkung
----------------------------------------------------------------

               8 Bit Ladebefehle
               -----------------

LD r,s         r := s              s= r, n, (HL),(IX+-e),(IY+-e)
LD d,r         d := r              d=    r, (HL),(IX+-e),(IY+-e)
LD d,n         d := n              d=       (HL),(IX+-e),(IY+-e)
LD A,s         A := s              s= (BC), (DE), (nn), I, R 
LD d,A         d := A              d= (BC), (DE), (nn), I, R

               16 Bit Ladebefehle
               ------------------

LD dd,nn       dd := nn            dd = BC, DE, HL, SP, IX, IY
LD dd,(aa)     dd := (aa)
LD (aa),ss     (aa) := ss          ss = BC, DE, HL, SP, IX, IY
LD SP,ss       SP := ss            ss = HL, IX, IY
PUSH ss        (SP-1) := ss(h)     ss = BC, DE, HL, IX, IY, AF
               (SP-2) := ss(l)
               SP := SP - 2
POP dd         dd(l) := (SP)       dd = BC, DE, HL, IX, IY, AF
               dd(h) := (SP+1)
               SP := SP + 2

               Registeraustauschbefehle
               ------------------------

EX (SP),ss     (SP) <--> ss(l)     ss = HL, IX, IY
               (SP+1) <--> ss(h)
EX DE,HL       DE <--> HL
EX AF oder 
EXAF           AF <--> AF'
EXX            BC <--> BC'
               DE <--> DE'
               HL <--> HL'

               Blocktransfer
               -------------

LDI            (DE) := (HL), DE+, HL+, BC-
LDIR           (DE) := (HL), DE+, HL+, BC-, solange, bis BC = 0
LDD            (DE) := (HL), DE-, HL-, BC-
LDDR           (DE) := (HL), DE-, HL-, BC-, solange, bis BC = 0

               Blocksuchbefehle
               ----------------

CPI            A vgl (HL), HL+, BC-
CPIR           A vgl (HL), HL+, BC-, solange, bis BC = 0  
                                              oder A = (HL); Z=1
CPD            A vgl (HL), HL-, BC-
CPDR           A vgl (HL), HL-, BC-, solange, bis BC = 0
                                              oder A = (HL); Z=1

Bei  den  Blocktransfer- und Blocksuchbefehlen ist das  Flag  P/V 
solange gesetzt, wie BC nicht Null ist.



Mnemonik       Operation           Bemerkung
----------------------------------------------------------------

               Rechenbefehle in A
               ------------------

ADD A,s        A := A + s          s=r, n, (HL), (IX+-e), (IY+-e)
ADD s

ADC A,s        A := A + s + CY
ADC s

SUB s          A := A - s

SBC A,s        A := A - s - CY
SBC s

AND s          A := A & s          Konjunktion
OR s           A := A v s          Disjunktion
XOR s          A := A x s          Inhibition

CP s           A vgl s
CMP s

INC d          d := d + 1          d = s, (HL), (IX+-e),(IY+-e)
DEC d          d := d - 1

               arithmetische Operationen 16 Bit
               --------------------------------

ADD HL,ss      HL := HL + ss       ss = BC, DE, HL, SP
ADC HL,ss      HL := HL + ss + CY
SBC HL,ss      HL := HL - ss - CY
ADD IX,ss      IX := IX + ss       ss = BC, DE, IX, SP
ADD IY,ss      IY := IY + ss       ss = BC, DE, IY, SP
INC dd         dd := dd + 1        dd = BC, DE, HL, SP, IX, IY
DEC dd         dd := dd - 1

               sonstige arithmetische Operationen
               ----------------------------------

DAA            Konvertierung in BCD im Register A, auf ADD oder
               SUB folgend
CPL            bitweises Komplement in A
NEG            A := 0 - A, Negation
CCF            Komplement Carry-Flag
SCF            CY := 1

               sonstige Operationen
               --------------------

NOP            keine Operation
HALT           CPU-Halt, nur mit Interrupt loesbar
DI             Interrupt verboten
EI             Interrupt erlaubt
IM0            Interruptmode 0, 8080-Mode
IM1            Interruptmode 1, CALL 38H
IM2            Interruptmode 2, indirekter CALL ueber Vektor



Mnemonik       Operation           Bemerkungen
----------------------------------------------------------------

               Verschiebebefehle
               -----------------

RLCA           CY<--7<-----0<--7   s = r, (HL),(IX+-e),(IY+-e)
RLC s                              sonst in Register A

RLA            CY<--7<-----0<--CY
RL s

RRCA           0-->7----->0-->CY
RRC s

RRA            CY-->7----->0-->CY
RR s

SLA s          CY<--7<-----0<--Null

SRA s          7-->7----->0-->CY

SRL s          Null-->7----->0-->CY

RLD            Rotation Bit 0--3 A     nach Bit 0--3  (HL)
                        Bit 0--3 (HL)  nach Bit 4--7  (HL)
                        Bit 4--7 (HL)  nach Bit 0--3  A 

RRD            Rotation Bit 0--3 A     nach Bit 4--7  (HL)
                        Bit 4--7 (HL)  nach Bit 0--3  (HL)
                        Bit 0--3 (HL)  nach Bit 0--3  A

Bei  beiden  Befehlen  bleiben  die  Bits  4--7  im  Register   A 
unberuehrt.

               Bitoperationen
               --------------

BIT b,s        Z := negiertes Bit b von s    Z ist Zero-Flag
RES b,s        Bit b von s := 0
SET b,s        Bit b von s := 1

               Ein- und Ausgaben
               -----------------

IN A,(n)       A := (port n)
IN n

IN r,(C)       r := (port (C))     r = A, B, C, D, E, H, L
IN r

INI            (HL) := (port(C)), HL+, B-
INIR           (HL) := (port(C)), HL+, B-, solange bis B = 0
IND            (HL) := (port(C)), HL-, B-
INDR           (HL) := (port(C)), HL-, B-, solange bis B = 0

OUT (n),A      (port n) := A
OUT n

OUT (C),r      (port(C)) := r
OUT r
Mnemonik       Operation           Bemerkungen
----------------------------------------------------------------

OUTI           (port(C)) := (HL), HL+, B-
OTIR           (port(C)) := (HL), HL+, B-, solange bis B = 0
OUTD           (port(C)) := (HL), HL-, B-
OTDR           (port(C)) := (HL), HL-, B-, solange bis B = 0

               Sprungbefehle
               -------------

JP aa          PC := aa                 Bei nicht erfuellter
JMP aa                                  Bedingung PC := PC + 3

JP NZ,aa       PC := aa, wenn Z = 0
JPNZ aa

JP Z,aa        PC := aa, wenn Z = 1
JPZ aa

JP NC,aa       PC := aa, wenn CY = 0
JPNC aa

JP C,aa        PC := aa, wenn CY = 1
JPC aa

JP PO,aa       PC := aa, wenn ungerade
JPPO aa

JP PE,aa       PC := aa, wenn gerade
JPPE aa

JP P,aa        PC := aa, wenn positiv
JPP aa

JP M,aa        PC := aa, wenn negativ
JPM aa

JP (ss)        PC := ss                 ss = HL, IX, IY

JR e           PC := e                  bei nicht erfuellter
                                        Bedingung wird PC:=PC+2  
JR NZ,e        PC := e, wenn Z = 0
JRNZ e

JR Z,e         PC := e, wenn Z = 1
JRZ e

JR NC,e        PC := e, wenn CY = 0
JRNC e

JR C,e         PC := e, wenn CY = 1
JRC e

DJNZ e         PC := e, solange, bis B = 0
               B := B - 1

Bei  der robotron-Mnemonik der relativen Spruenge ist die  Angabe 
nach e (meistens +# oder -#) wegzulassen!


Mnemonik       Operation           Bemerkung
----------------------------------------------------------------

               Unterprogammaufrufe
               -------------------

CALL aa        (SP-1) := PC(h)     Dieser Ablauf gilt stets bei
               (SP-2) := PC(l)     erfuellter Bedingung, sonst
               SP := SP - 2        wird PC := PC + 3

CALL NZ,aa     Aufruf, wenn Z = 0
CANZ aa

CALL Z,aa      Aufruf, wenn Z = 1
CAZ aa

CALL NC,aa     Aufruf, wenn CY = 0
CANC aa

CALL C,aa      Aufruf, wenn CY = 1
CAC aa

CALL PO,aa     Aufruf, wenn ungerade
CAPO aa

CALL PE,aa     Aufruf, wenn gerade
CAPE aa

CALL P,aa      Aufruf, wenn positiv
CAP aa

CALL M,aa      Aufruf, wenn negativ
CAM aa

RST L          (SP-1) := PC(h)
               (SP-2) := PC(l)
               SP := SP -2
               PC(h) := 0
               PC(l) := L

               Rueckspruenge
               -------------

RET            PC(l) := (SP)       Dieser Ablauf gilt immer, wenn
               PC(h) := (SP+1)     die Bedingung erfuellt ist,
               SP := SP + 2        wird PC := PC + 1

RET NZ         Ruecksprung, wenn Z = 0
RNZ

RET Z          Ruecksprung, wenn Z = 1
RZ

RET NC         Ruecksprung, wenn CY = 0
RNC

RET C          Ruecksprung, wenn CY = 1
RC

RET PO         Ruecksprung, wenn ungerade
RPO
Mnemonik       Operation           Bemerkung
---------------------------------------------------------------

RET PE         Ruecksprung, wenn gerade
RPE

RET P          Ruecksprung, wenn positiv
RP

RET M          Ruecksprung, wenn negativ
RM

RETI           Rueckkehr vom Interrupt, sonst wie RET
RETN           Rueckkehr vom nicht maskierten Interrupt, sonst
               wie RET

Ausserdem  sind noch folgende sogen.  nichtbekannte   Operationen 
mit  implementiert,  die  die  Indexregister  als  Einzelregister 
behandeln. Es ist vor ihrer Anwendung der Prozessor zu testen, ob 
er diese Befehle richtig ausfuehrt!
Die  Operationen werden wie die anderen Operationen mit  normalen 
Register ausgefuehrt. Hier wird nur die Mnemonik angegeben:

INC HX         INC HY         INC LX         INC LY
DEC HX         DEC HY         DEC LX         DEC LY
ADD A,HX       ADD A,HY       ADD A,LX       ADD A,LY
SUB HX         SUB HY         SUB LX         SUB LY
AND HX         AND HY         AND LX         AND LY
OR  HX         OR  HY         OR  LX         OR  LY
ADC A,HX       ADC A,HY       ADC A,LX       ADC A,LY
SBC A,HX       SBC A,HY       SBC A,LX       SBC A,LY
XOR HX         XOR HY         XOR LX         XOR LY
CP  HX         CP  HY         CP  LX         CP  LY

               LD HX,LX       LD LX,HX       LD LX,LX
               LD HY,LY       LD LY,HY       LD LY,LY
LD r,HX        LD r,HY        LD r,LX        LD r,LY
LD HX,r        LD HY,r        LD LX,r        LD LY,r

r ist eines der Register A, B, C, D, E
LX  oder  LY  bezeichnet die unteren 8 Bit  und HX  oder  HY  die 
oberen 8 Bit eines Indexregisters
